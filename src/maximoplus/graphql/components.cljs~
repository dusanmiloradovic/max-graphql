(ns maximoplus.graphql.components
  (:require [maximoplus.basecontrols :as b :refer [UI Field Row Table ControlData Foundation Dialog Picker Workflow GL]]
            [maximoplus.core :as c]
            [maximoplus.utils :as u])
  (:require-macros [maximoplus.macros :as mm :refer [def-comp googbase kk! kk-nocb! kk-branch-nocb! p-deferred p-deferred-on react-call with-react-props react-prop react-update-field react-call-control react-loop-fields loop-arr]])
  )

;;this will hold the implementions of the core library components. Containers are "final", and this is what will be used to do the queries and mutations (AppContainers and CommandContainers). However, for subscriptions we need to adapt the visual componets, because they react to the messages from the server. Also, the routeWF, changeStatus, getValueList will be easier implemented with the Visual Components then with the containers
(defn not-used;;assure basecomponents don't call the method, not used in reactive. After the extensive testing, all methods having the call to this can be deleted
  []
  (throw (js/Error. "should not be called")))

;;/bacic unit of information, all the data handling will be done on the List level

(def-comp ListRow [container columns mxrow disprow] b/GridRow
  (^override fn* [] (this-as this (googbase this container columns mxrow disprow)))
  UI
  (^override draw-row [this]
   (b/mark-as-displayed this);;this will allow the listener to attach(here listener is just state)
   );;rendering done in react
  (^override draw-field [this]);rendering done in react
  (^override draw-fields [this]);first version of react will give us just the list, when we are ready to implement the grid, we will call this methid and make the listrow component which inherits this. we don't 
  (^override add-rendered-child [this rendered-child child]);rendering composition should be done in React
  Row
  (^override set-row-flags
   [this colfglags]
   (not-used));in the fist version the rows will be read only , so this is not imporant
  (^override highlight-selected-row
   [this]
   (not-used))
  (^override unhighlight-selected-row
   [this]
   (not-used))
  (^override listen-row
   [this rowSelectedActionF])
  (^override get-disp-row
   [this]
   (not-used))
  (^override set-disprow! [this dr]
   (not-used))
  (^override set-row-value
   [this column value]
   (not-used)
   )
  (^override set-row-values
   [this colvals]
   (not-used)
   )
  (add-default-lookups [this columns])
  (^override set-field-flag
   [this field flag]
   (not-used))
  )

;;list holds the set of informations

(def-comp List [container columns norows] b/Grid 
  (^override fn* []
   (this-as this (googbase this container columns norows)))
  Table
  (^override main-grid-frame [this])
  (^override grid-toolbar [this])
  (^override get-qbe-row [this])
  (^override get-label-row [this])
  (^override qbe-row [this])
  (^override header-row [this])
  (^override get-row-control
   [this mxrow disprow]
   (GridRow. container columns mxrow disprow))
  (^override set-grid-row-values
   [this row values]
   (set-row-state-bulk-data-or-flags this row "data" values ))
  (^override set-grid-row-value
   [this row column value]
   (set-row-state-data-or-flags this row column "data" value))
  (^override set-grid-row-flags
   [this row flags]
   (set-row-state-bulk-data-or-flags this row "flags" flags))
  (^override mark-grid-row-as-selected
   [this row selected?]
   (set-row-state-meta this row "selected" selected?))
  (^override update-paginator [this fromRow toRow numRows]
   (set-wrapped-state this "paginator" #js{:fromrow fromRow :torow toRow :numrows numRows}))
  (^override highlight-grid-row
   [this row]
   (set-row-state-meta this row "hightlighed" true))
  (^override unhighlight-grid-row
   [this row]
   (set-row-state-meta this row "hightlighed" false))
  Reactive
  (set-row-state-data-or-flags
   [this row column type value];;type is data or flag
   (let [rows-state (safe-arr-clone (get-wrapped-state this "maxrows"))
         row-data (-> rows-state (u/first-in-arr #(= (b/get-maximo-row row) (aget % "mxrow"))) (aget type ))] ;;every implementation will have this function
     (aset row-data column value)
     (set-wrapped-state this "maxrows" rows-state)))
  (set-row-state-bulk-data-or-flags
   [this row type colvals]
   (let [rows-state  (safe-arr-clone (get-wrapped-state this "maxrows"))
         row-data (-> rows-state (u/first-in-arr #(= (b/get-maximo-row row) (aget % "mxrow"))) (aget type ))]
     (if (object-empty? row-data)
       (aset (-> rows-state (u/first-in-arr #(= (b/get-maximo-row row) (aget % "mxrow")))) type colvals)
       (loop-arr [k (js-keys colvals)]
                 (aset row-data k (aget colvals k))))
      (set-wrapped-state this "maxrows" rows-state)))
  (set-row-state-meta
   [this row meta value]
   (let [rows-state (safe-arr-clone (get-wrapped-state this "maxrows"))
         row (-> rows-state (u/first-in-arr #(= (b/get-maximo-row row) (aget % "mxrow"))))]
     (aset row meta value)
     (set-wrapped-state this "maxrows" rows-state)))
  (remove-row-state-meta
   [this row meta]
   (let [rows-state  (safe-arr-clone (get-wrapped-state this "maxrows"))
         row (-> rows-state (u/first-in-arr #(= (b/get-maximo-row row) (aget % "mxrow"))))]
     (js-delete row meta)
     (set-wrapped-state this "maxrows" rows-state)))
  (add-new-row-state-data
   [this row colvals colflags]
   (let  [rows-state  (safe-arr-clone (get-wrapped-state this "maxrows"))
          new-maximo-row  (b/get-maximo-row row)
          rows-count (ar/count rows-state)]
     (if (and
          (> 0 rows-count)
          (<= (js/parseInt new-maximo-row) (-> rows-state (aget (- rows-count 1)) (aget "mxrow") (js/parseInt)) ))
       (ar/insert-before! rows-state new-maximo-row #js{:mxrow new-maximo-row :data colvals :flags colflags})
       (ar/conj! rows-state #js{:mxrow new-maximo-row :data colvals :flags colflags} ))
     (set-wrapped-state this "maxrows" rows-state)))
  (del-row-state-data
   [this row]
   (let  [
          rows-state (safe-arr-clone (get-wrapped-state this "maxrows"))
          new-maximo-row (b/get-maximo-row row)]
     (when rows-state
       (ar/remove-at! rows-state (u/first-ind-in-arr rows-state #(= (aget % "mxrow") new-maximo-row )))
       (set-wrapped-state this "maxrows" rows-state))))
  UI
  (^override render-row
   [this row]
   (add-new-row-state-data this row #js{} #js{}))
  (^override render-row-before
   [this row existing-row]
   (add-new-row-state-data this row #js{} #js{});same as before becuase the functions rearanges the rows based on the mxrow
   )
  Foundation
  (^override dispose-child
   [this row]
   (del-row-state-data this row))
  Picker
  (^override pick-row
   [this row]
   (set-row-state-meta this row "picked" true))
  (^override unpick-row
   [this row]
   (remove-row-state-meta this row "picked"))
  )
